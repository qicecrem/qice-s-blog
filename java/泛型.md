Java泛型,旨在提供编译时的类型安全检测机制，并支持编写可重用的、与具体数据类型无关的代码。它的本质是参数化类型——将类型作为参数传递给类、接口或方法，使代码能处理多种数据类型而不牺牲类型安全。
# 使用场景
## 泛型类（Generic Class）
定义类时声明类型参数（如T），在类内部作为实际类型使用。
```java
public class Box<T> {
    private T content;

    public void setContent(T content) {
        this.content = content;
    }

    public T getContent() {
        return content;
    }
}

// 使用
Box<String> stringBox = new Box<>();
stringBox.setContent("Text");
String value = stringBox.getContent(); // 直接返回String类型
```
##  泛型接口（Generic Interface）
接口定义类型参数，实现类可指定具体类型。
```java
public interface Repository<T> {
    void save(T entity);
    T findById(int id);
}

// 实现类
public class UserRepository implements Repository<User> {
    @Override
    public void save(User user) { ... }
    
    @Override
    public User findById(int id) { ... }
}
```
## 泛型方法（Generic Method）
在方法签名中声明类型参数（如<E>），独立于类的泛型参数。
```java
public class Utils {
    // 将数组转换为List（E由输入数组类型推断）
    public static <E> List<E> toList(E[] array) {
        return Arrays.asList(array);
    }
}

// 使用
String[] arr = {"A", "B", "C"};
List<String> list = Utils.toList(arr); // 自动推断E为String
```
# 关键特性详解
## 类型参数命名规范
- T - Type（常用）

- E - Element（集合元素）

- K - Key（键）

- V - Value（值）

- N - Number（数字类型）
## 类型限定
通过extends或super约束类型参数的范围：

- 上界（Upper Bound）：<T extends Number> 表示T必须是Number或其子类。

- 下界（Lower Bound）：<? super Integer> 表示类型需是Integer或其父类。

## 通配符（Wildcards）
- ?：未知类型（如List<?> 表示元素类型未知的列表）。

- ? extends T：上界通配符（只能读取数据）。

- ? super T：下界通配符（可写入数据）。
```
// 示例：复制数据（使用PECS原则：Producer-Extends, Consumer-Super）
public static void copy(List<? extends Number> src, List<? super Number> dest) {
    for (Number num : src) {
        dest.add(num);
    }
}
```

## 类型擦除（Type Erasure）
Java泛型在编译后会被擦除为原始类型（Raw Type），并在必要时插入强制转换。这是为了兼容旧版本Java。

- 泛型类Box<T>编译后变为Box（原始类型）。

- 类型变量T被替换为上限（如未指定上限则替换为Object）。